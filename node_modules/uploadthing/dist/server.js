"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// package.json
var require_package = __commonJS({
  "package.json"(exports, module2) {
    module2.exports = {
      name: "uploadthing",
      version: "5.6.1",
      license: "MIT",
      exports: {
        "./package.json": "./package.json",
        "./client": {
          types: "./dist/client.d.ts",
          import: "./dist/client.mjs",
          require: "./dist/client.js"
        },
        "./server": {
          types: "./dist/server.d.ts",
          import: "./dist/server.mjs",
          require: "./dist/server.js"
        },
        "./next": {
          types: "./dist/next.d.ts",
          import: "./dist/next.mjs",
          require: "./dist/next.js"
        },
        "./next-legacy": {
          types: "./dist/next-legacy.d.ts",
          import: "./dist/next-legacy.mjs",
          require: "./dist/next-legacy.js"
        },
        "./express": {
          import: "./dist/express.mjs",
          types: "./dist/express.d.ts",
          require: "./dist/express.js"
        },
        "./tw": {
          types: "./dist/tw.d.ts",
          import: "./dist/tw.mjs",
          require: "./dist/tw.js"
        },
        "./fastify": {
          types: "./dist/fastify.d.ts",
          import: "./dist/fastify.mjs",
          require: "./dist/fastify.js"
        }
      },
      files: [
        "dist"
      ],
      publishConfig: {
        access: "public"
      },
      typesVersions: {
        "*": {
          client: [
            "dist/client.d.ts"
          ],
          server: [
            "dist/server.d.ts"
          ],
          next: [
            "dist/next.d.ts"
          ],
          "next-legacy": [
            "dist/next-legacy.d.ts"
          ],
          tw: [
            "dist/tw.d.ts"
          ],
          express: [
            "dist/express.d.ts"
          ],
          fastify: [
            "dist/fastify.d.ts"
          ]
        }
      },
      scripts: {
        lint: 'eslint "**/*.{ts,tsx}" --max-warnings 0',
        build: "tsup",
        clean: "git clean -xdf dist node_modules",
        dev: "tsup --watch",
        test: "vitest run",
        "test:watch": "vitest",
        typecheck: "tsc --noEmit"
      },
      dependencies: {
        "@uploadthing/mime-types": "^0.2.1",
        "@uploadthing/shared": "^5.2.2"
      },
      devDependencies: {
        "@types/express": "^4.17.17",
        "@types/react": "18.2.8",
        "@uploadthing/eslint-config": "0.2.0",
        "@uploadthing/tsconfig": "0.1.0",
        "@uploadthing/tsup-config": "0.1.0",
        eslint: "^8.47.0",
        express: "^4.18.2",
        fastify: "^4.22.0",
        next: "13.4.4",
        "solid-js": "^1.7.11",
        tailwindcss: "^3.3.2",
        tsup: "6.7.0",
        "type-fest": "^3.11.1",
        typescript: "^5.1.6",
        undici: "^5.20.0",
        vitest: "^0.30.1",
        zod: "^3.21.4"
      },
      eslintConfig: {
        root: true,
        extends: [
          "@uploadthing/eslint-config/base"
        ]
      }
    };
  }
});

// src/server.ts
var server_exports = {};
__export(server_exports, {
  VALID_ACTION_TYPES: () => VALID_ACTION_TYPES,
  createServerHandler: () => createServerHandler,
  createUploadthing: () => createUploadthing,
  extractRouterConfig: () => extractRouterConfig,
  unsetMarker: () => unsetMarker,
  utapi: () => sdk_exports
});
module.exports = __toCommonJS(server_exports);
var import_shared5 = require("@uploadthing/shared");

// src/constants.ts
var packageJson = require_package();
if (!packageJson.version)
  throw new Error("no version found in package.json");
var UPLOADTHING_VERSION = packageJson.version;

// src/internal/error-formatter.ts
function defaultErrorFormatter(error) {
  return {
    message: error.message
  };
}
function formatError(error, router) {
  var _a;
  const errorFormatter = ((_a = router[Object.keys(router)[0]]) == null ? void 0 : _a._def.errorFormatter) ?? defaultErrorFormatter;
  return errorFormatter(error);
}

// src/internal/handler.ts
var import_shared2 = require("@uploadthing/shared");

// src/internal/dev-hook.ts
var import_shared = require("@uploadthing/shared");
var isValidResponse = (response) => {
  if (!response.ok)
    return false;
  if (response.status >= 400)
    return false;
  if (!response.headers.has("x-uploadthing-version"))
    return false;
  return true;
};
var conditionalDevServer = async (fileKey) => {
  if (process.env.NODE_ENV !== "development")
    return;
  const fileData = await (0, import_shared.pollForFileData)(
    fileKey,
    async (json) => {
      const file = json.fileData;
      let callbackUrl = file.callbackUrl + `?slug=${file.callbackSlug}`;
      if (!callbackUrl.startsWith("http"))
        callbackUrl = "http://" + callbackUrl;
      console.log("[UT] SIMULATING FILE UPLOAD WEBHOOK CALLBACK", callbackUrl);
      const response = await fetch(callbackUrl, {
        method: "POST",
        body: JSON.stringify({
          status: "uploaded",
          metadata: JSON.parse(file.metadata ?? "{}"),
          file: {
            url: `https://utfs.io/f/${encodeURIComponent(fileKey)}`,
            key: fileKey,
            name: file.fileName,
            size: file.fileSize
          }
        }),
        headers: {
          "uploadthing-hook": "callback"
        }
      });
      if (isValidResponse(response)) {
        console.log("[UT] Successfully simulated callback for file", fileKey);
      } else {
        console.error(
          "[UT] Failed to simulate callback for file. Is your webhook configured correctly?",
          fileKey
        );
      }
      return file;
    }
  );
  if (fileData !== null)
    return fileData;
  console.error(`[UT] Failed to simulate callback for file ${fileKey}`);
  throw new import_shared.UploadThingError({
    code: "UPLOAD_FAILED",
    message: "File took too long to upload"
  });
};

// src/internal/parser.ts
function getParseFn(parser) {
  if (typeof parser.parse === "function") {
    return parser.parse;
  }
  throw new Error("Invalid parser");
}

// src/internal/types.ts
var unsetMarker = "unsetMarker";
var VALID_ACTION_TYPES = ["upload", "failure"];

// src/internal/handler.ts
var fileCountLimitHit = (files, routeConfig) => {
  var _a;
  const counts = {};
  files.forEach((file) => {
    const type = (0, import_shared2.getTypeFromFileName)(
      file,
      Object.keys(routeConfig)
    );
    if (!counts[type]) {
      counts[type] = 1;
    } else {
      counts[type] += 1;
    }
  });
  for (const _key in counts) {
    const key = _key;
    const count = counts[key];
    const limit = (_a = routeConfig[key]) == null ? void 0 : _a.maxFileCount;
    if (!limit) {
      console.error(routeConfig, key);
      throw new import_shared2.UploadThingError({
        code: "BAD_REQUEST",
        message: "Invalid config during file count",
        cause: `Expected route config to have a maxFileCount for key ${key} but none was found.`
      });
    }
    if (count > limit) {
      return { limitHit: true, type: key, limit, count };
    }
  }
  return { limitHit: false };
};
var getHeader = (req, key) => {
  if (req.headers instanceof Headers) {
    return req.headers.get(key);
  }
  return req.headers[key];
};
var buildRequestHandler = (opts) => {
  return async (input) => {
    if (process.env.NODE_ENV === "development") {
      console.log("[UT] UploadThing dev server is now running!");
    }
    const { req, res } = input;
    const { router, config } = opts;
    const preferredOrEnvSecret = (config == null ? void 0 : config.uploadthingSecret) ?? process.env.UPLOADTHING_SECRET;
    const params = new URL(req.url ?? "", (0, import_shared2.getUploadthingUrl)()).searchParams;
    const uploadthingHook = getHeader(req, "uploadthing-hook") ?? void 0;
    const slug = params.get("slug") ?? void 0;
    const actionType = params.get("actionType") ?? void 0;
    if (!slug)
      return new import_shared2.UploadThingError({
        code: "BAD_REQUEST",
        message: "No slug provided"
      });
    if (slug && typeof slug !== "string") {
      return new import_shared2.UploadThingError({
        code: "BAD_REQUEST",
        message: "`slug` must be a string",
        cause: `Expected slug to be of type 'string', got '${typeof slug}'`
      });
    }
    if (actionType && typeof actionType !== "string") {
      return new import_shared2.UploadThingError({
        code: "BAD_REQUEST",
        message: "`actionType` must be a string",
        cause: `Expected actionType to be of type 'string', got '${typeof actionType}'`
      });
    }
    if (uploadthingHook && typeof uploadthingHook !== "string") {
      return new import_shared2.UploadThingError({
        code: "BAD_REQUEST",
        message: "`uploadthingHook` must be a string",
        cause: `Expected uploadthingHook to be of type 'string', got '${typeof uploadthingHook}'`
      });
    }
    if (!preferredOrEnvSecret) {
      return new import_shared2.UploadThingError({
        code: "BAD_REQUEST",
        message: `Please set your preferred secret in ${slug} router's config or set UPLOADTHING_SECRET in your env file`,
        cause: "No secret provided"
      });
    }
    const uploadable = router[slug];
    if (!uploadable) {
      return new import_shared2.UploadThingError({
        code: "NOT_FOUND",
        message: `No file route found for slug ${slug}`
      });
    }
    if (uploadthingHook === "callback") {
      const reqBody = await req.json();
      await uploadable.resolver({
        file: reqBody.file,
        metadata: reqBody.metadata
      });
      return { status: 200 };
    }
    if (!actionType || !VALID_ACTION_TYPES.includes(actionType)) {
      return new import_shared2.UploadThingError({
        code: "BAD_REQUEST",
        cause: `Invalid action type ${actionType}`,
        message: `Expected ${VALID_ACTION_TYPES.map((x) => `"${x}"`).join(", ").replace(/,(?!.*,)/, " or")} but got "${"a"}"`
      });
    }
    switch (actionType) {
      case "upload": {
        const { files, input: userInput } = await req.json();
        let parsedInput = {};
        try {
          const inputParser = uploadable._def.inputParser;
          parsedInput = await getParseFn(inputParser)(userInput);
        } catch (error) {
          console.error(error);
          return new import_shared2.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid input.",
            cause: error
          });
        }
        let metadata = {};
        try {
          metadata = await uploadable._def.middleware({
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            req,
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
            res,
            input: parsedInput
          });
        } catch (error) {
          console.error(error);
          return new import_shared2.UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to run middleware.",
            cause: error
          });
        }
        if (!Array.isArray(files) || !files.every((f) => typeof f === "string"))
          return new import_shared2.UploadThingError({
            code: "BAD_REQUEST",
            message: "Files must be a string array",
            cause: `Expected files to be of type 'string[]', got '${JSON.stringify(
              files
            )}'`
          });
        let parsedConfig;
        try {
          parsedConfig = (0, import_shared2.fillInputRouteConfig)(
            uploadable._def.routerConfig
          );
        } catch (error) {
          console.error(error);
          return new import_shared2.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config.",
            cause: error
          });
        }
        try {
          const { limitHit, count, limit, type } = fileCountLimitHit(
            files,
            parsedConfig
          );
          if (limitHit) {
            return new import_shared2.UploadThingError({
              code: "BAD_REQUEST",
              message: "File limit exceeded",
              cause: `You uploaded ${count} files of type '${type}', but the limit for that type is ${limit}`
            });
          }
        } catch (error) {
          console.error(error);
          return new import_shared2.UploadThingError({
            code: "BAD_REQUEST",
            message: "Invalid config.",
            cause: error
          });
        }
        const uploadthingApiResponse = await fetch(
          (0, import_shared2.generateUploadThingURL)("/api/prepareUpload"),
          {
            method: "POST",
            body: JSON.stringify({
              files,
              routeConfig: parsedConfig,
              metadata,
              callbackUrl: (config == null ? void 0 : config.callbackUrl) ?? (0, import_shared2.getUploadthingUrl)(),
              callbackSlug: slug
            }),
            headers: {
              "Content-Type": "application/json",
              "x-uploadthing-api-key": preferredOrEnvSecret,
              "x-uploadthing-version": UPLOADTHING_VERSION
            }
          }
        );
        if (!uploadthingApiResponse.ok) {
          console.error("[UT] unable to get presigned urls");
          try {
            const error = await uploadthingApiResponse.json();
            console.error(error);
            return new import_shared2.UploadThingError({
              code: "BAD_REQUEST",
              cause: error
            });
          } catch (cause) {
            console.error("[UT] unable to parse response");
            return new import_shared2.UploadThingError({
              code: "URL_GENERATION_FAILED",
              message: "Unable to get presigned urls",
              cause
            });
          }
        }
        const parsedResponse = await uploadthingApiResponse.json();
        if (process.env.NODE_ENV === "development") {
          for (const file of parsedResponse) {
            void conditionalDevServer(file.key);
          }
        }
        return { body: parsedResponse, status: 200 };
      }
      case "failure": {
        const { fileKey } = await req.json();
        const uploadthingApiResponse = await fetch(
          (0, import_shared2.generateUploadThingURL)("/api/failureCallback"),
          {
            method: "POST",
            body: JSON.stringify({
              fileKey
            }),
            headers: {
              "Content-Type": "application/json",
              "x-uploadthing-api-key": preferredOrEnvSecret,
              "x-uploadthing-version": UPLOADTHING_VERSION
            }
          }
        );
        if (!uploadthingApiResponse.ok) {
          console.error("[UT] failed to mark upload as failed");
          try {
            const error = await uploadthingApiResponse.json();
            console.error(error);
            return new import_shared2.UploadThingError({
              message: "Failed to mark upload as failed",
              code: "INTERNAL_SERVER_ERROR",
              cause: error
            });
          } catch (cause) {
            console.error("[UT] unable to parse response");
            return new import_shared2.UploadThingError({
              code: "URL_GENERATION_FAILED",
              message: "Unable to get presigned urls",
              cause
            });
          }
        }
        try {
          uploadable._def.onUploadError({
            error: new import_shared2.UploadThingError({
              code: "UPLOAD_FAILED",
              message: `Upload failed for ${fileKey}`
            }),
            fileKey
          });
        } catch (error) {
          console.error(
            "[UT] Failed to run onUploadError callback. You probably shouldn't be throwing errors in your callback."
          );
          console.error(error);
          return new import_shared2.UploadThingError({
            code: "INTERNAL_SERVER_ERROR",
            message: "Failed to run onUploadError callback",
            cause: error
          });
        }
        return { status: 200 };
      }
      default: {
        return new import_shared2.UploadThingError({
          code: "BAD_REQUEST",
          message: `Invalid action type`
        });
      }
    }
  };
};
var buildPermissionsInfoHandler = (opts) => {
  return () => {
    const r = opts.router;
    const permissions = Object.keys(r).map((k) => {
      const route = r[k];
      const config = (0, import_shared2.fillInputRouteConfig)(route._def.routerConfig);
      return {
        slug: k,
        config
      };
    });
    return permissions;
  };
};

// src/internal/upload-builder.ts
function internalCreateBuilder(initDef = {}) {
  const _def = {
    // Default router config
    routerConfig: {
      image: {
        maxFileSize: "4MB"
      }
    },
    inputParser: { parse: () => ({}), _input: {}, _output: {} },
    middleware: () => ({}),
    onUploadError: () => ({}),
    errorFormatter: initDef.errorFormatter ?? defaultErrorFormatter,
    // Overload with properties passed in
    ...initDef
  };
  return {
    input(userParser) {
      return internalCreateBuilder({
        ..._def,
        inputParser: userParser
      });
    },
    middleware(userMiddleware) {
      return internalCreateBuilder({
        ..._def,
        middleware: userMiddleware
      });
    },
    onUploadComplete(userUploadComplete) {
      return {
        _def,
        resolver: userUploadComplete
      };
    },
    onUploadError(userOnUploadError) {
      return internalCreateBuilder({
        ..._def,
        onUploadError: userOnUploadError
      });
    }
  };
}
function createBuilder(opts) {
  return (input) => {
    return internalCreateBuilder({
      routerConfig: input,
      ...opts
    });
  };
}

// src/sdk/index.ts
var sdk_exports = {};
__export(sdk_exports, {
  deleteFiles: () => deleteFiles,
  getFileUrls: () => getFileUrls,
  listFiles: () => listFiles,
  renameFile: () => renameFile,
  uploadFiles: () => uploadFiles,
  uploadFilesFromUrl: () => uploadFilesFromUrl
});
var import_shared4 = require("@uploadthing/shared");

// src/sdk/utils.ts
var import_shared3 = require("@uploadthing/shared");

// src/internal/s3-error-parser.ts
var maybeParseResponseXML = (maybeXml) => {
  const codeMatch = maybeXml.match(/<Code>(.*?)<\/Code>/s);
  const messageMatch = maybeXml.match(/<Message>(.*?)<\/Message>/s);
  const code = codeMatch == null ? void 0 : codeMatch[1];
  const message = messageMatch == null ? void 0 : messageMatch[1];
  if (!code || !message)
    return null;
  return { code: s3CodeToUploadThingCode[code] ?? DEFAULT_ERROR_CODE, message };
};
var DEFAULT_ERROR_CODE = "UPLOAD_FAILED";
var s3CodeToUploadThingCode = {
  AccessDenied: "FORBIDDEN",
  // 403 Forbidden
  EntityTooSmall: "TOO_SMALL",
  // 400 Bad Request
  EntityTooLarge: "TOO_LARGE",
  // 400 Bad Request
  ExpiredToken: "FORBIDDEN",
  // 400 Bad Request
  IncorrectNumberOfFilesInPostRequest: "TOO_MANY_FILES",
  // 400 Bad Request
  InternalError: "INTERNAL_SERVER_ERROR",
  // 500 Internal Server Error
  KeyTooLongError: "KEY_TOO_LONG",
  // 400 Bad Request
  MaxMessageLengthExceeded: "TOO_LARGE"
  // 400 Bad Request
};

// src/sdk/utils.ts
var uploadFilesInternal = async (data, opts) => {
  const fileData = data.files.map((file) => ({
    name: file.name ?? "unnamed-blob",
    type: file.type,
    size: file.size
  }));
  const res = await fetch((0, import_shared3.generateUploadThingURL)("/api/uploadFiles"), {
    method: "POST",
    headers: {
      "x-uploadthing-api-key": opts.apiKey,
      "x-uploadthing-version": opts.utVersion
    },
    cache: "no-store",
    body: JSON.stringify({
      files: fileData,
      metadata: data.metadata
    })
  });
  if (!res.ok) {
    const error = await import_shared3.UploadThingError.fromResponse(res);
    throw error;
  }
  const clonedRes = res.clone();
  const json = await res.json();
  if ("error" in json) {
    const error = await import_shared3.UploadThingError.fromResponse(clonedRes);
    throw error;
  }
  const uploads = await Promise.allSettled(
    data.files.map(async (file, i) => {
      const { presignedUrl, fields, key, fileUrl } = json.data[i];
      if (!presignedUrl || !fields) {
        throw new import_shared3.UploadThingError({
          code: "URL_GENERATION_FAILED",
          message: "Failed to generate presigned URL",
          cause: JSON.stringify(json.data[i])
        });
      }
      const formData = new FormData();
      formData.append("Content-Type", file.type);
      Object.entries(fields).forEach(([key2, value]) => {
        formData.append(key2, value);
      });
      formData.append(
        "file",
        // Handles case when there is no file name
        file.name ? file : Object.assign(file, { name: "unnamed-blob" })
      );
      const s3res = await fetch(presignedUrl, {
        method: "POST",
        body: formData,
        headers: new Headers({
          Accept: "application/xml"
        })
      });
      if (!s3res.ok) {
        await fetch((0, import_shared3.generateUploadThingURL)("/api/failureCallback"), {
          method: "POST",
          body: JSON.stringify({
            fileKey: fields.key
          }),
          headers: {
            "x-uploadthing-api-key": opts.apiKey,
            "x-uploadthing-version": opts.utVersion
          }
        });
        const text = await s3res.text();
        const parsed = maybeParseResponseXML(text);
        if (parsed == null ? void 0 : parsed.message) {
          throw new import_shared3.UploadThingError({
            code: "UPLOAD_FAILED",
            message: parsed.message
          });
        }
        throw new import_shared3.UploadThingError({
          code: "UPLOAD_FAILED",
          message: "Failed to upload file to storage provider",
          cause: s3res
        });
      }
      await (0, import_shared3.pollForFileData)(key);
      return {
        key,
        url: fileUrl,
        name: file.name,
        size: file.size
      };
    })
  );
  return uploads.map((upload) => {
    if (upload.status === "fulfilled") {
      const data2 = upload.value;
      return { data: data2, error: null };
    }
    const reason = upload.reason;
    const error = import_shared3.UploadThingError.toObject(reason);
    return { data: null, error };
  });
};

// src/sdk/index.ts
function guardServerOnly() {
  if (typeof window !== "undefined") {
    throw new import_shared4.UploadThingError({
      code: "INTERNAL_SERVER_ERROR",
      message: "The `utapi` can only be used on the server."
    });
  }
}
function getApiKeyOrThrow() {
  if (!process.env.UPLOADTHING_SECRET) {
    throw new import_shared4.UploadThingError({
      code: "MISSING_ENV",
      message: "Missing `UPLOADTHING_SECRET` env variable."
    });
  }
  return process.env.UPLOADTHING_SECRET;
}
var uploadFiles = async (files, metadata = {}) => {
  guardServerOnly();
  const filesToUpload = Array.isArray(files) ? files : [files];
  const uploads = await uploadFilesInternal(
    {
      files: filesToUpload,
      metadata
    },
    {
      apiKey: getApiKeyOrThrow(),
      utVersion: UPLOADTHING_VERSION
    }
  );
  const uploadFileResponse = Array.isArray(files) ? uploads : uploads[0];
  return uploadFileResponse;
};
var uploadFilesFromUrl = async (urls, metadata = {}) => {
  guardServerOnly();
  const fileUrls = Array.isArray(urls) ? urls : [urls];
  const formData = new FormData();
  formData.append("metadata", JSON.stringify(metadata));
  const filesToUpload = await Promise.all(
    fileUrls.map(async (url) => {
      if (typeof url === "string")
        url = new URL(url);
      const filename = url.pathname.split("/").pop() ?? "unknown-filename";
      const fileResponse = await fetch(url);
      if (!fileResponse.ok) {
        throw new import_shared4.UploadThingError({
          code: "BAD_REQUEST",
          message: "Failed to download requested file.",
          cause: fileResponse
        });
      }
      const blob = await fileResponse.blob();
      return Object.assign(blob, { name: filename });
    })
  );
  const uploads = await uploadFilesInternal(
    {
      files: filesToUpload,
      metadata
    },
    {
      apiKey: getApiKeyOrThrow(),
      utVersion: UPLOADTHING_VERSION
    }
  );
  const uploadFileResponse = Array.isArray(urls) ? uploads : uploads[0];
  return uploadFileResponse;
};
var deleteFiles = async (fileKeys) => {
  guardServerOnly();
  if (!Array.isArray(fileKeys))
    fileKeys = [fileKeys];
  const res = await fetch((0, import_shared4.generateUploadThingURL)("/api/deleteFile"), {
    method: "POST",
    cache: "no-store",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    },
    body: JSON.stringify({ fileKeys })
  });
  if (!res.ok) {
    throw new Error("Failed to delete files");
  }
  return res.json();
};
var getFileUrls = async (fileKeys) => {
  guardServerOnly();
  if (!Array.isArray(fileKeys))
    fileKeys = [fileKeys];
  const res = await fetch((0, import_shared4.generateUploadThingURL)("/api/getFileUrl"), {
    method: "POST",
    cache: "no-store",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    },
    body: JSON.stringify({ fileKeys })
  });
  if (!res.ok) {
    throw new Error("Failed to get file urls");
  }
  return res.json().then(({ data }) => data);
};
var listFiles = async () => {
  guardServerOnly();
  const res = await fetch((0, import_shared4.generateUploadThingURL)("/api/listFiles"), {
    method: "POST",
    cache: "no-store",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    }
  });
  const json = await res.json();
  if (!res.ok || "error" in json) {
    const message = "error" in json ? json.error : "Unknown error";
    throw new Error(message);
  }
  return json.files;
};
var renameFile = async (updates) => {
  guardServerOnly();
  if (!Array.isArray(updates))
    updates = [updates];
  const res = await fetch((0, import_shared4.generateUploadThingURL)("/api/renameFile"), {
    method: "POST",
    cache: "no-store",
    headers: {
      "Content-Type": "application/json",
      "x-uploadthing-api-key": getApiKeyOrThrow(),
      "x-uploadthing-version": UPLOADTHING_VERSION
    },
    body: JSON.stringify({ updates })
  });
  const json = await res.json();
  if (!res.ok || "error" in json) {
    const message = "error" in json ? json.error : "Unknown error";
    throw new Error(message);
  }
  return json;
};

// src/server.ts
var createUploadthing = (opts) => createBuilder(opts);
var createServerHandler = (opts) => {
  const requestHandler = buildRequestHandler(opts);
  const POST = async (request) => {
    const req = request instanceof Request ? request : request.request;
    const response = await requestHandler({ req });
    if (response instanceof import_shared5.UploadThingError) {
      return new Response(JSON.stringify(formatError(response, opts.router)), {
        status: (0, import_shared5.getStatusCodeFromError)(response),
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    if (response.status !== 200) {
      return new Response("An unknown error occured", {
        status: 500,
        headers: {
          "x-uploadthing-version": UPLOADTHING_VERSION
        }
      });
    }
    return new Response(JSON.stringify(response.body), {
      status: response.status,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  const getBuildPerms = buildPermissionsInfoHandler(opts);
  const GET = (request) => {
    const _req = request instanceof Request ? request : request.request;
    return new Response(JSON.stringify(getBuildPerms()), {
      status: 200,
      headers: {
        "x-uploadthing-version": UPLOADTHING_VERSION
      }
    });
  };
  return { GET, POST };
};
var extractRouterConfig = (router) => buildPermissionsInfoHandler({ router })();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  VALID_ACTION_TYPES,
  createServerHandler,
  createUploadthing,
  extractRouterConfig,
  unsetMarker,
  utapi
});
//# sourceMappingURL=server.js.map